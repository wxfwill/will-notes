# js 作用域、执行上下文、作用域链

> [原文地址](https://coffe1891.gitbook.io/frontend-hard-mode-interview/1/1.2.2)

:::tip
**作用域即函数或变量的可见区域**，通俗来讲，函数或者变量不在这个区域内，就无法访问到
:::

## 函数作用域

```js
// 全局作用域
function func() {
  // 作用域a
  var a = "coffe";
  function func1() {
    // 作用域b, 定义一个函数，把不想公开的内容隐藏起来
    var a = "1990"; // 这里的a把外层的a覆盖了
    var b = "b";

    // 这里面的变量或者函数对外层隐藏，外层访问不到
    // ....
    console.log(a);
  }
  console.log(a); // coffe
  console.log(b); // undefined
  func1(); // 1990
}
```

上面示例了一个嵌套函数，等于有外层函数 func 的作用域 A 内嵌了函数 func1 的作用域 B。在 func1 里面的打印命令 console.log(a)访问变量 a 时，**JS 引擎会先从离自己最近的作用域**A 查找变量 a，找到就不再继续查找，找不到就去上层作用域（此例中上层作用域是全局作用域）继续查找，此例中 a 已经找到且值为"coffe"，所以打印输出 coffe。依此类推，执行 func1()，会执行 func1 函数内部的 console.log(a)，随即会在作用域 B 查找里面 a，而作用 B 里面存在一个 a 的声明和赋值语句 var a = "1990"，所以最先找到 a 的值是 1990，找到便不再继续查找，最终 func1()输出 1990 而不是 coffe。

## ES6 带来了块级作用域

- ES6 规定，在某一个花括号对{}的内部用**let 关键字声明的变量和函数拥有块级作用域**，这些变量和函数只能在花括号`{}`的内部使用，外部不可以访问，在写下代码的时候，变量和函数的块级作用域已经确定下来，**块级作用域和函数作用域也可以统称为局部作用域**
- ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，在块级作用域之中，函数声明语句的行为类似于 let，在块级作用域之外不可引用。但是这样的处理规则显然会对老代码产生很大的影响，出于向后（backward）兼容的考虑，在块级作用域中声明的函数依然可以在作用域外部引用。如果需要函数只在块级作用域中起作用，应该用 let 关键字写成函数表达式，而不是函数声明语句。

```js
{
  function func() {
    //函数声明
    return 1;
  }
}
console.log(func()); //>> 1
```

上面这段代码，函数 func 明明是在花括号内部声明的，按 ES6 原本的规范，外部应该是不可访问的，但实际上可以，证明 JS 引擎为了向后兼容在实现 ES6 规范的时候做了变通处理。再来看一段代码

```js
{
  var func = function() {
    //未使用let关键字的函数表达式
    return 1;
  };
}
console.log(func()); //>> 1
```

上面这段代码与它之前那一段代码效果是一样。

```js
{
  let func = function() {
    return 1;
  };
}
console.log(func()); //>> func is not defined
```

上面这段代码证明，在花括号{}内部由 let 关键字声明的函数，才是真正的处于块级作用域内部。

## 为什么要引进块级作用域

- 有了全局作用域和函数作用域，以及 var 已经挺好用的了，为何还要引进块级作用域和关键字 let 呢？
- 首先，的确，ES6 之前函数作用域和 var 结合也很好用，但是终究没有{}和 let 结合来的块级作用域来的简洁！
- 其次，var 声明的变量有副作用：**声明提前。**

```js
(function() {
  console.log(a); //>> undefined
  console.log(b); //>> ReferenceError
  var a = "coffe"; //声明提前
  let b = "1891"; //由let关键字声明的变量，不存在提前的特性
})();
```

上面这段代码，其中`var a = "coffe"` 含两个操作，一个是变量 a 的声明（也即`var a`)，一个是赋值（也即`a = "coffe"`）。声明提前的意思是，用`var`关键字声明的变量，其实可以看做是在函数体内最顶端声明的，所以`console.log(a)`输出`undefined`，代表该变量已经被声明过（但还未赋值）。声明提前这个特性，让很多程序员容易变得十分迷惑。按理说，变量（或函数）应是在声明之后才能读取（查找）的，但是 var 已经让这个常理变得近似诡异，let 的出现能让这诡异回归常理。

## 执行上下文

### 定义

:::tip
**定义：** 执行上下文就是当前 JavaScript 代码被解析和执行时所在的环境，也叫作执行环境。
:::

### 类型

- 执行上下文总共有三种类型：
- **全局执行上下文：** 这是默认的、最基础的执行上下文。不在任何函数中的代码都位于全局执行上下文中。它做了两件事：1. 创建一个全局对象，在浏览器中这个全局对象就是 window 对象；2. 将 this 指针指向这个全局对象。一个程序中只能存在一个全局执行上下文。
- **函数执行上下文：** 每次调用函数时，都会为该函数创建一个新的执行上下文。每个函数都拥有自己的执行上下文，但是只有在函数被调用的时候才会被创建。一个程序中可以存在任意数量的函数执行上下文。每当一个新的执行上下文被创建，它都会按照特定的顺序执行一系列步骤，具体过程将在本文后面讨论。
- eval 执行上下文：运行在 eval 函数中的代码也获得了自己的执行上下文，ES6 之后不再推荐使用 eval 函数，所以本书出于面试实用考虑，不会深入讨论 eval。

### 执行上下文的生命周期

> 执行上下文的生命周期包括三个阶段：`创建阶段` → `执行阶段` → `回收阶段`，本文重点介绍`创建阶段`

**a.创建阶段**

- 当函数被调用，但未执行任何其内部代码之前，会做以下三件事：
- 1.创建变量对象：首先初始化函数的参数 arguments，提升函数声明和变量声明（变量的声明提前有赖于 var 关键字）。
- 2.创建作用域链：在执行期上下文的创建阶段，作用域链是在变量对象之后创建的。作用域链本身包含变量对象。作用域链用于解析变量。当被要求解析变量时，JavaScript 始终从代码嵌套的最内层开始，如果最内层没有找到变量，就会跳转到上一层父作用域中查找，直到找到该变量。
- 3.确定 this 指向

**b.执行阶段**

- 创建完成之后，就会开始执行代码，在这个阶段，会完成变量赋值、函数引用、以及执行其他代码

**c.回收阶段**

- 函数调用完毕后，函数出栈，对应的执行上下文也出栈，等待垃圾回收器回收执行上下文。

### 执行上下文栈

```js
var a = "coffe"; //1.进入全局执行上下文
function out() {
  var b = "18";
  function inner() {
    var c = "91";
    console.log(a + b + c);
  }
  inner(); //3.进入inner函数的执行上下文
}
out(); //2.进入out函数的执行上下文
```
